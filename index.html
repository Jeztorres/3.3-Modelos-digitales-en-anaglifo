<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - effects - anaglyph</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="css/main.css">
</head>

<body>
	<div id="info">
		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Modelo 3D con efecto anaglifo<br />
		Usa gafas rojo-azul para ver el efecto 3D<br />
		<strong>Desarrollado por: Jezrael Jared Gomez Torres</strong>
	</div>

	<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.158.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
				}
			}
		</script>

	<script type="module">

		import * as THREE from 'three';

		import { AnaglyphEffect } from 'three/addons/effects/AnaglyphEffect.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		let container, camera, scene, renderer, effect, controls;
		let model, mixer, clock;

		init();

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1000);
			camera.position.set(0, 1.5, 4); // Posición más cercana para un modelo más pequeño

			// Crear el reloj para las animaciones
			clock = new THREE.Clock();

			scene = new THREE.Scene();
			// Fondo gris como en la imagen
			scene.background = new THREE.Color(0x808080);

			// Agregar iluminación para el modelo 3D
			const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
			scene.add(ambientLight);

			const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
			directionalLight.position.set(1, 1, 0).normalize();
			scene.add(directionalLight);

			// Agregar una grilla en el suelo como en la imagen
			const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x444444);
			gridHelper.position.y = -2;
			scene.add(gridHelper);

			// Configurar OrbitControls para rotar, hacer zoom y mover la cámara
			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			container.appendChild(renderer.domElement);

			controls = new OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true; // Movimiento suave
			controls.dampingFactor = 0.05;
			controls.minDistance = 2; // Zoom mínimo
			controls.maxDistance = 15; // Zoom máximo
			controls.target.set(0, 0, 0); // Punto al que mira la cámara
			controls.update();

			// Cargar el modelo GLB
			const loader = new GLTFLoader();

			// Configurar DRACOLoader para descomprimir geometría
			const dracoLoader = new DRACOLoader();
			dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
			loader.setDRACOLoader(dracoLoader);

			console.log('Intentando cargar modelo-final.glb...');

			// GitHub Pages no soporta LFS, cargar desde GitHub Release
			const modelUrl = 'https://github.com/Jeztorres/3.3-Modelos-digitales-en-anaglifo/releases/download/v1.0/modelo-final.glb';

			loader.load(modelUrl, function (gltf) {

				model = gltf.scene;

				// Calcular el tamaño del modelo para escalarlo apropiadamente
				const box = new THREE.Box3().setFromObject(model);
				const center = box.getCenter(new THREE.Vector3());
				const size = box.getSize(new THREE.Vector3());

				console.log('Tamaño del modelo:', size);
				console.log('Centro del modelo:', center);

				// Escalar el modelo para que tenga un tamaño razonable (más pequeño)
				const maxSize = Math.max(size.x, size.y, size.z);
				const scale = 1.2 / maxSize; // Hacer que el modelo tenga aprox 1.2 unidades de alto
				model.scale.setScalar(scale);

				// Recalcular el bounding box después de escalar
				box.setFromObject(model);

				// Centrar el modelo horizontalmente y colocarlo exactamente en el piso
				model.position.x = -center.x * scale;
				model.position.y = -box.min.y - 2; // Colocar exactamente en el piso (grilla está en y=-2)
				model.position.z = -center.z * scale;

				console.log('Escala aplicada:', scale);
				console.log('Posición final:', model.position);

				// Configurar materiales del modelo
				model.traverse(function (child) {
					if (child.isMesh) {
						if (child.material) {
							if (Array.isArray(child.material)) {
								child.material.forEach(material => {
									material.needsUpdate = true;
								});
							} else {
								child.material.needsUpdate = true;
							}
						}
					}
				});

				// Configurar animaciones si existen
				if (gltf.animations && gltf.animations.length > 0) {
					mixer = new THREE.AnimationMixer(model);

					console.log('Animaciones encontradas:', gltf.animations.length);
					gltf.animations.forEach((clip, index) => {
						console.log(`Animación ${index}: ${clip.name}, duración: ${clip.duration}s`);
					});

					// Reproducir la primera animación
					const action = mixer.clipAction(gltf.animations[0]);
					action.play();

					console.log('Reproduciendo animación:', gltf.animations[0].name);
				} else {
					console.log('No se encontraron animaciones en el modelo');
				}

				scene.add(model);
				console.log('Modelo GLB cargado exitosamente!');

			}, function (progress) {
				console.log('Cargando modelo.glb: ' + (progress.loaded / progress.total * 100) + '%');
			}, function (error) {
				console.error('Error al cargar modelo.glb:', error);
			});

			// Efecto anaglifo
			renderer.setAnimationLoop(animate);

			const width = window.innerWidth || 2;
			const height = window.innerHeight || 2;

			effect = new AnaglyphEffect(renderer);
			effect.setSize(width, height);
			
			// Aumentar la separación entre ojos para un efecto 3D más pronunciado
			// Valor por defecto es ~0.064, aumentamos a 0.15 para efecto más dramático
			effect.setEyeSeparation(0.15);

			//

			window.addEventListener('resize', onWindowResize);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			effect.setSize(window.innerWidth, window.innerHeight);

		}

		//

		function animate() {

			render();

		}

		function render() {

			const delta = clock.getDelta();

			// Actualizar controles para permitir zoom y rotación
			controls.update();

			// Actualizar animaciones si existen
			if (mixer) {
				mixer.update(delta);
			}

			effect.render(scene, camera);

		}

	</script>

</body>

</html>